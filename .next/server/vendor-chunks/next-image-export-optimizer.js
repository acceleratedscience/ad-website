"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/next-image-export-optimizer";
exports.ids = ["vendor-chunks/next-image-export-optimizer"];
exports.modules = {

/***/ "(ssr)/./node_modules/next-image-export-optimizer/dist/ExportedImage.js":
/*!************************************************************************!*\
  !*** ./node_modules/next-image-export-optimizer/dist/ExportedImage.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var next_image__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! next/image */ \"(ssr)/./node_modules/next/image.js\");\n/* harmony import */ var next_image__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(next_image__WEBPACK_IMPORTED_MODULE_1__);\n/* __next_internal_client_entry_do_not_use__ default auto */ \n\nconst splitFilePath = ({ filePath })=>{\n    const filenameWithExtension = filePath.split(\"\\\\\").pop()?.split(\"/\").pop() || \"\";\n    const filePathWithoutFilename = filePath.split(filenameWithExtension).shift();\n    const fileExtension = filePath.split(\".\").pop();\n    const filenameWithoutExtension = filenameWithExtension.substring(0, filenameWithExtension.lastIndexOf(\".\")) || filenameWithExtension;\n    return {\n        path: filePathWithoutFilename,\n        filename: filenameWithoutExtension,\n        extension: fileExtension || \"\"\n    };\n};\nconst generateImageURL = (src, width, isRemoteImage = false)=>{\n    const { filename, path, extension } = splitFilePath({\n        filePath: src\n    });\n    const useWebp =  true ? true : 0;\n    if (![\n        \"JPG\",\n        \"JPEG\",\n        \"WEBP\",\n        \"PNG\",\n        \"AVIF\",\n        \"GIF\"\n    ].includes(extension.toUpperCase())) {\n        // The images has an unsupported extension\n        // We will return the src\n        return src;\n    }\n    // If the images are stored as WEBP by the package, then we should change\n    // the extension to WEBP to load them correctly\n    let processedExtension = extension;\n    if (useWebp && [\n        \"JPG\",\n        \"JPEG\",\n        \"PNG\",\n        \"GIF\"\n    ].includes(extension.toUpperCase())) {\n        processedExtension = \"WEBP\";\n    }\n    let correctedPath = path;\n    const lastChar = correctedPath?.substr(-1); // Selects the last character\n    if (lastChar != \"/\") {\n        // If the last character is not a slash\n        correctedPath = correctedPath + \"/\"; // Append a slash to it.\n    }\n    const isStaticImage = src.includes(\"_next/static/media\");\n    const exportFolderName = \"nextImageExportOptimizer\" || 0;\n    let generatedImageURL = `${isStaticImage ? \"\" : correctedPath}${exportFolderName}/${filename}-opt-${width}.${processedExtension.toUpperCase()}`;\n    // if the generatedImageURL is not starting with a slash, then we add one as long as it is not a remote image\n    if (!isRemoteImage && generatedImageURL.charAt(0) !== \"/\") {\n        generatedImageURL = \"/\" + generatedImageURL;\n    }\n    return generatedImageURL;\n};\nfunction urlToFilename(url) {\n    // Remove the protocol from the URL\n    let filename = url.replace(/^(https?|ftp):\\/\\//, \"\");\n    // Replace special characters with underscores\n    filename = filename.replace(/[/\\\\:*?\"<>|#%]/g, \"_\");\n    // Remove control characters\n    filename = filename.replace(/[\\x00-\\x1F\\x7F]/g, \"\");\n    // Trim any leading or trailing spaces\n    filename = filename.trim();\n    return filename;\n}\nconst imageURLForRemoteImage = ({ src, width })=>{\n    const encodedSrc = urlToFilename(src);\n    return generateImageURL(encodedSrc, width, true);\n};\nconst optimizedLoader = ({ src, width })=>{\n    const isStaticImage = typeof src === \"object\";\n    const _src = isStaticImage ? src.src : src;\n    const originalImageWidth = isStaticImage && src.width || undefined;\n    // if it is a static image, we can use the width of the original image to generate a reduced srcset that returns\n    // the same image url for widths that are larger than the original image\n    if (isStaticImage && originalImageWidth && width > originalImageWidth) {\n        const deviceSizes = {\"deviceSizes\":[640,750,828,1080,1200,1920,2048,3840],\"imageSizes\":[16,32,48,64,96,128,256,384],\"path\":\"/_next/image/\",\"loader\":\"custom\",\"dangerouslyAllowSVG\":false,\"unoptimized\":false,\"domains\":[],\"remotePatterns\":[],\"output\":\"export\"}?.deviceSizes || [\n            640,\n            750,\n            828,\n            1080,\n            1200,\n            1920,\n            2048,\n            3840\n        ];\n        const imageSizes = {\"deviceSizes\":[640,750,828,1080,1200,1920,2048,3840],\"imageSizes\":[16,32,48,64,96,128,256,384],\"path\":\"/_next/image/\",\"loader\":\"custom\",\"dangerouslyAllowSVG\":false,\"unoptimized\":false,\"domains\":[],\"remotePatterns\":[],\"output\":\"export\"}?.imageSizes || [\n            16,\n            32,\n            48,\n            64,\n            96,\n            128,\n            256,\n            384\n        ];\n        const allSizes = [\n            ...deviceSizes,\n            ...imageSizes\n        ];\n        // only use the width if it is smaller or equal to the next size in the allSizes array\n        let nextLargestSize = null;\n        for(let i = 0; i < allSizes.length; i++){\n            if (Number(allSizes[i]) >= originalImageWidth && (nextLargestSize === null || Number(allSizes[i]) < nextLargestSize)) {\n                nextLargestSize = Number(allSizes[i]);\n            }\n        }\n        if (nextLargestSize !== null) {\n            return generateImageURL(_src, nextLargestSize);\n        }\n    }\n    // Check if the image is a remote image (starts with http or https)\n    if (_src.startsWith(\"http\")) {\n        return imageURLForRemoteImage({\n            src: _src,\n            width\n        });\n    }\n    return generateImageURL(_src, width);\n};\nconst fallbackLoader = ({ src })=>{\n    let _src = typeof src === \"object\" ? src.src : src;\n    const isRemoteImage = _src.startsWith(\"http\");\n    // if the _src does not start with a slash, then we add one as long as it is not a remote image\n    if (!isRemoteImage && _src.charAt(0) !== \"/\") {\n        _src = \"/\" + _src;\n    }\n    return _src;\n};\nconst ExportedImage = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(({ src, priority = false, loading, className, width, height, onLoadingComplete, unoptimized, placeholder = \"blur\", blurDataURL, style, onError, ...rest }, ref)=>{\n    const [imageError, setImageError] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const automaticallyCalculatedBlurDataURL = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        if (blurDataURL) {\n            // use the user provided blurDataURL if present\n            return blurDataURL;\n        }\n        // check if the src is specified as a local file -> then it is an object\n        const isStaticImage = typeof src === \"object\";\n        const _src = isStaticImage ? src.src : src;\n        if (unoptimized === true) {\n            // return the src image when unoptimized\n            return _src;\n        }\n        // Check if the image is a remote image (starts with http or https)\n        if (_src.startsWith(\"http\")) {\n            return imageURLForRemoteImage({\n                src: _src,\n                width: 10\n            });\n        }\n        // otherwise use the generated image of 10px width as a blurDataURL\n        return generateImageURL(_src, 10);\n    }, [\n        blurDataURL,\n        src,\n        unoptimized\n    ]);\n    // check if the src is a SVG image -> then we should not use the blurDataURL and use unoptimized\n    const isSVG = typeof src === \"object\" ? src.src.endsWith(\".svg\") : src.endsWith(\".svg\");\n    const [blurComplete, setBlurComplete] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    // Currently, we have to handle the blurDataURL ourselves as the new Image component\n    // is expecting a base64 encoded string, but the generated blurDataURL is a normal URL\n    const blurStyle = placeholder === \"blur\" && !isSVG && automaticallyCalculatedBlurDataURL && automaticallyCalculatedBlurDataURL.startsWith(\"/\") && !blurComplete ? {\n        backgroundSize: style?.objectFit || \"cover\",\n        backgroundPosition: style?.objectPosition || \"50% 50%\",\n        backgroundRepeat: \"no-repeat\",\n        backgroundImage: `url(${automaticallyCalculatedBlurDataURL})`,\n        filter: \"url(#sharpBlur)\"\n    } : undefined;\n    const ImageElement = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement((next_image__WEBPACK_IMPORTED_MODULE_1___default()), {\n        ref: ref,\n        ...rest,\n        ...width && {\n            width\n        },\n        ...height && {\n            height\n        },\n        ...loading && {\n            loading\n        },\n        ...className && {\n            className\n        },\n        ...onLoadingComplete && {\n            onLoadingComplete\n        },\n        ...placeholder && {\n            placeholder: blurStyle || blurComplete ? \"empty\" : placeholder\n        },\n        ...unoptimized && {\n            unoptimized\n        },\n        ...priority && {\n            priority\n        },\n        ...isSVG && {\n            unoptimized: true\n        },\n        style: {\n            ...style,\n            ...blurStyle\n        },\n        loader: imageError || unoptimized === true ? fallbackLoader : (e)=>optimizedLoader({\n                src,\n                width: e.width\n            }),\n        blurDataURL: automaticallyCalculatedBlurDataURL,\n        onError: (error)=>{\n            setImageError(true);\n            setBlurComplete(true);\n            // execute the onError function if provided\n            onError && onError(error);\n        },\n        onLoadingComplete: (result)=>{\n            // for some configurations, the onError handler is not called on an error occurrence\n            // so we need to check if the image is loaded correctly\n            if (result.naturalWidth === 0) {\n                // Broken image, fall back to unoptimized (meaning the original image src)\n                setImageError(true);\n            }\n            setBlurComplete(true);\n            // execute the onLoadingComplete callback if present\n            onLoadingComplete && onLoadingComplete(result);\n        },\n        src: src\n    });\n    // When we present a placeholder, we add a svg filter to the image and remove it after either\n    // the image is loaded or an error occurred\n    return blurStyle ? /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement((react__WEBPACK_IMPORTED_MODULE_0___default().Fragment), null, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"noscript\", null, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement((next_image__WEBPACK_IMPORTED_MODULE_1___default()), {\n        ...rest,\n        ...width && {\n            width\n        },\n        ...height && {\n            height\n        },\n        ...loading && {\n            loading\n        },\n        ...className && {\n            className\n        },\n        placeholder: \"empty\",\n        ...unoptimized && {\n            unoptimized\n        },\n        ...priority && {\n            priority\n        },\n        style: style,\n        loader: imageError || unoptimized === true ? fallbackLoader : (e)=>optimizedLoader({\n                src,\n                width: e.width\n            }),\n        src: src\n    })), ImageElement, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"svg\", {\n        style: {\n            border: 0,\n            clip: \"rect(0 0 0 0)\",\n            height: 0,\n            margin: \"-1px\",\n            overflow: \"hidden\",\n            padding: 0,\n            position: \"absolute\",\n            width: \"1px\"\n        }\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"filter\", {\n        id: \"sharpBlur\"\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"feGaussianBlur\", {\n        stdDeviation: \"20\",\n        colorInterpolationFilters: \"sRGB\"\n    }), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"feColorMatrix\", {\n        type: \"matrix\",\n        colorInterpolationFilters: \"sRGB\",\n        values: \"1 0 0 0 0, 0 1 0 0 0, 0 0 1 0 0, 0 0 0 9 0\"\n    }), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"feComposite\", {\n        in2: \"SourceGraphic\",\n        operator: \"in\"\n    })))) : ImageElement;\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ExportedImage);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbmV4dC1pbWFnZS1leHBvcnQtb3B0aW1pemVyL2Rpc3QvRXhwb3J0ZWRJbWFnZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs2REFDNkQ7QUFDOUI7QUFDL0IsTUFBTUssZ0JBQWdCLENBQUMsRUFBRUMsUUFBUSxFQUFFO0lBQy9CLE1BQU1DLHdCQUF3QkQsU0FBU0UsS0FBSyxDQUFDLE1BQU1DLEdBQUcsSUFBSUQsTUFBTSxLQUFLQyxTQUFTO0lBQzlFLE1BQU1DLDBCQUEwQkosU0FBU0UsS0FBSyxDQUFDRCx1QkFBdUJJLEtBQUs7SUFDM0UsTUFBTUMsZ0JBQWdCTixTQUFTRSxLQUFLLENBQUMsS0FBS0MsR0FBRztJQUM3QyxNQUFNSSwyQkFBMkJOLHNCQUFzQk8sU0FBUyxDQUFDLEdBQUdQLHNCQUFzQlEsV0FBVyxDQUFDLFNBQVNSO0lBQy9HLE9BQU87UUFDSFMsTUFBTU47UUFDTk8sVUFBVUo7UUFDVkssV0FBV04saUJBQWlCO0lBQ2hDO0FBQ0o7QUFDQSxNQUFNTyxtQkFBbUIsQ0FBQ0MsS0FBS0MsT0FBT0MsZ0JBQWdCLEtBQUs7SUFDdkQsTUFBTSxFQUFFTCxRQUFRLEVBQUVELElBQUksRUFBRUUsU0FBUyxFQUFFLEdBQUdiLGNBQWM7UUFBRUMsVUFBVWM7SUFBSTtJQUNwRSxNQUFNRyxVQUFVQyxLQUFxRUcsR0FDL0VILElBQXdELEdBQ3hELENBQUk7SUFDVixJQUFJLENBQUM7UUFBQztRQUFPO1FBQVE7UUFBUTtRQUFPO1FBQVE7S0FBTSxDQUFDSSxRQUFRLENBQUNWLFVBQVVXLFdBQVcsS0FBSztRQUNsRiwwQ0FBMEM7UUFDMUMseUJBQXlCO1FBQ3pCLE9BQU9UO0lBQ1g7SUFDQSx5RUFBeUU7SUFDekUsK0NBQStDO0lBQy9DLElBQUlVLHFCQUFxQlo7SUFDekIsSUFBSUssV0FDQTtRQUFDO1FBQU87UUFBUTtRQUFPO0tBQU0sQ0FBQ0ssUUFBUSxDQUFDVixVQUFVVyxXQUFXLEtBQUs7UUFDakVDLHFCQUFxQjtJ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QyxrQkFBa0I7UUFBRXFHLGNBQWM7UUFBTUMsMkJBQTJCO0lBQU8sa0JBQzlGdEcsMERBQW1CLENBQUMsaUJBQWlCO1FBQUV1RyxNQUFNO1FBQVVELDJCQUEyQjtRQUFRRSxRQUFRO0lBQTZDLGtCQUMvSXhHLDBEQUFtQixDQUFDLGVBQWU7UUFBRXlHLEtBQUs7UUFBaUJDLFVBQVU7SUFBSyxRQUFVcEI7QUFDcEc7QUFDQSxpRUFBZTVCLGFBQWFBLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pYm0tYWQtbmV4dC13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL25leHQtaW1hZ2UtZXhwb3J0LW9wdGltaXplci9kaXN0L0V4cG9ydGVkSW1hZ2UuanM/ZWYwMyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBjbGllbnRcIjtcbmltcG9ydCBSZWFjdCwgeyBmb3J3YXJkUmVmLCB1c2VNZW1vLCB1c2VTdGF0ZSB9IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IEltYWdlIGZyb20gXCJuZXh0L2ltYWdlXCI7XG5jb25zdCBzcGxpdEZpbGVQYXRoID0gKHsgZmlsZVBhdGggfSkgPT4ge1xuICAgIGNvbnN0IGZpbGVuYW1lV2l0aEV4dGVuc2lvbiA9IGZpbGVQYXRoLnNwbGl0KFwiXFxcXFwiKS5wb3AoKT8uc3BsaXQoXCIvXCIpLnBvcCgpIHx8IFwiXCI7XG4gICAgY29uc3QgZmlsZVBhdGhXaXRob3V0RmlsZW5hbWUgPSBmaWxlUGF0aC5zcGxpdChmaWxlbmFtZVdpdGhFeHRlbnNpb24pLnNoaWZ0KCk7XG4gICAgY29uc3QgZmlsZUV4dGVuc2lvbiA9IGZpbGVQYXRoLnNwbGl0KFwiLlwiKS5wb3AoKTtcbiAgICBjb25zdCBmaWxlbmFtZVdpdGhvdXRFeHRlbnNpb24gPSBmaWxlbmFtZVdpdGhFeHRlbnNpb24uc3Vic3RyaW5nKDAsIGZpbGVuYW1lV2l0aEV4dGVuc2lvbi5sYXN0SW5kZXhPZihcIi5cIikpIHx8IGZpbGVuYW1lV2l0aEV4dGVuc2lvbjtcbiAgICByZXR1cm4ge1xuICAgICAgICBwYXRoOiBmaWxlUGF0aFdpdGhvdXRGaWxlbmFtZSxcbiAgICAgICAgZmlsZW5hbWU6IGZpbGVuYW1lV2l0aG91dEV4dGVuc2lvbixcbiAgICAgICAgZXh0ZW5zaW9uOiBmaWxlRXh0ZW5zaW9uIHx8IFwiXCIsXG4gICAgfTtcbn07XG5jb25zdCBnZW5lcmF0ZUltYWdlVVJMID0gKHNyYywgd2lkdGgsIGlzUmVtb3RlSW1hZ2UgPSBmYWxzZSkgPT4ge1xuICAgIGNvbnN0IHsgZmlsZW5hbWUsIHBhdGgsIGV4dGVuc2lvbiB9ID0gc3BsaXRGaWxlUGF0aCh7IGZpbGVQYXRoOiBzcmMgfSk7XG4gICAgY29uc3QgdXNlV2VicCA9IHByb2Nlc3MuZW52Lm5leHRJbWFnZUV4cG9ydE9wdGltaXplcl9zdG9yZVBpY3R1cmVzSW5XRUJQICE9IHVuZGVmaW5lZFxuICAgICAgICA/IHByb2Nlc3MuZW52Lm5leHRJbWFnZUV4cG9ydE9wdGltaXplcl9zdG9yZVBpY3R1cmVzSW5XRUJQXG4gICAgICAgIDogdHJ1ZTtcbiAgICBpZiAoIVtcIkpQR1wiLCBcIkpQRUdcIiwgXCJXRUJQXCIsIFwiUE5HXCIsIFwiQVZJRlwiLCBcIkdJRlwiXS5pbmNsdWRlcyhleHRlbnNpb24udG9VcHBlckNhc2UoKSkpIHtcbiAgICAgICAgLy8gVGhlIGltYWdlcyBoYXMgYW4gdW5zdXBwb3J0ZWQgZXh0ZW5zaW9uXG4gICAgICAgIC8vIFdlIHdpbGwgcmV0dXJuIHRoZSBzcmNcbiAgICAgICAgcmV0dXJuIHNyYztcbiAgICB9XG4gICAgLy8gSWYgdGhlIGltYWdlcyBhcmUgc3RvcmVkIGFzIFdFQlAgYnkgdGhlIHBhY2thZ2UsIHRoZW4gd2Ugc2hvdWxkIGNoYW5nZVxuICAgIC8vIHRoZSBleHRlbnNpb24gdG8gV0VCUCB0byBsb2FkIHRoZW0gY29ycmVjdGx5XG4gICAgbGV0IHByb2Nlc3NlZEV4dGVuc2lvbiA9IGV4dGVuc2lvbjtcbiAgICBpZiAodXNlV2VicCAmJlxuICAgICAgICBbXCJKUEdcIiwgXCJKUEVHXCIsIFwiUE5HXCIsIFwiR0lGXCJdLmluY2x1ZGVzKGV4dGVuc2lvbi50b1VwcGVyQ2FzZSgpKSkge1xuICAgICAgICBwcm9jZXNzZWRFeHRlbnNpb24gPSBcIldFQlBcIjtcbiAgICB9XG4gICAgbGV0IGNvcnJlY3RlZFBhdGggPSBwYXRoO1xuICAgIGNvbnN0IGxhc3RDaGFyID0gY29ycmVjdGVkUGF0aD8uc3Vic3RyKC0xKTsgLy8gU2VsZWN0cyB0aGUgbGFzdCBjaGFyYWN0ZXJcbiAgICBpZiAobGFzdENoYXIgIT0gXCIvXCIpIHtcbiAgICAgICAgLy8gSWYgdGhlIGxhc3QgY2hhcmFjdGVyIGlzIG5vdCBhIHNsYXNoXG4gICAgICAgIGNvcnJlY3RlZFBhdGggPSBjb3JyZWN0ZWRQYXRoICsgXCIvXCI7IC8vIEFwcGVuZCBhIHNsYXNoIHRvIGl0LlxuICAgIH1cbiAgICBjb25zdCBpc1N0YXRpY0ltYWdlID0gc3JjLmluY2x1ZGVzKFwiX25leHQvc3RhdGljL21lZGlhXCIpO1xuICAgIGNvbnN0IGV4cG9ydEZvbGRlck5hbWUgPSBwcm9jZXNzLmVudi5uZXh0SW1hZ2VFeHBvcnRPcHRpbWl6ZXJfZXhwb3J0Rm9sZGVyTmFtZSB8fFxuICAgICAgICBcIm5leHRJbWFnZUV4cG9ydE9wdGltaXplclwiO1xuICAgIGxldCBnZW5lcmF0ZWRJbWFnZVVSTCA9IGAke2lzU3RhdGljSW1hZ2UgPyBcIlwiIDogY29ycmVjdGVkUGF0aH0ke2V4cG9ydEZvbGRlck5hbWV9LyR7ZmlsZW5hbWV9LW9wdC0ke3dpZHRofS4ke3Byb2Nlc3NlZEV4dGVuc2lvbi50b1VwcGVyQ2FzZSgpfWA7XG4gICAgLy8gaWYgdGhlIGdlbmVyYXRlZEltYWdlVVJMIGlzIG5vdCBzdGFydGluZyB3aXRoIGEgc2xhc2gsIHRoZW4gd2UgYWRkIG9uZSBhcyBsb25nIGFzIGl0IGlzIG5vdCBhIHJlbW90ZSBpbWFnZVxuICAgIGlmICghaXNSZW1vdGVJbWFnZSAmJiBnZW5lcmF0ZWRJbWFnZVVSTC5jaGFyQXQoMCkgIT09IFwiL1wiKSB7XG4gICAgICAgIGdlbmVyYXRlZEltYWdlVVJMID0gXCIvXCIgKyBnZW5lcmF0ZWRJbWFnZVVSTDtcbiAgICB9XG4gICAgcmV0dXJuIGdlbmVyYXRlZEltYWdlVVJMO1xufTtcbmZ1bmN0aW9uIHVybFRvRmlsZW5hbWUodXJsKSB7XG4gICAgLy8gUmVtb3ZlIHRoZSBwcm90b2NvbCBmcm9tIHRoZSBVUkxcbiAgICBsZXQgZmlsZW5hbWUgPSB1cmwucmVwbGFjZSgvXihodHRwcz98ZnRwKTpcXC9cXC8vLCBcIlwiKTtcbiAgICAvLyBSZXBsYWNlIHNwZWNpYWwgY2hhcmFjdGVycyB3aXRoIHVuZGVyc2NvcmVzXG4gICAgZmlsZW5hbWUgPSBmaWxlbmFtZS5yZXBsYWNlKC9bL1xcXFw6Kj9cIjw+fCMlXS9nLCBcIl9cIik7XG4gICAgLy8gUmVtb3ZlIGNvbnRyb2wgY2hhcmFjdGVyc1xuICAgIGZpbGVuYW1lID0gZmlsZW5hbWUucmVwbGFjZSgvW1xceDAwLVxceDFGXFx4N0ZdL2csIFwiXCIpO1xuICAgIC8vIFRyaW0gYW55IGxlYWRpbmcgb3IgdHJhaWxpbmcgc3BhY2VzXG4gICAgZmlsZW5hbWUgPSBmaWxlbmFtZS50cmltKCk7XG4gICAgcmV0dXJuIGZpbGVuYW1lO1xufVxuY29uc3QgaW1hZ2VVUkxGb3JSZW1vdGVJbWFnZSA9ICh7IHNyYywgd2lkdGgsIH0pID0+IHtcbiAgICBjb25zdCBlbmNvZGVkU3JjID0gdXJsVG9GaWxlbmFtZShzcmMpO1xuICAgIHJldHVybiBnZW5lcmF0ZUltYWdlVVJMKGVuY29kZWRTcmMsIHdpZHRoLCB0cnVlKTtcbn07XG5jb25zdCBvcHRpbWl6ZWRMb2FkZXIgPSAoeyBzcmMsIHdpZHRoLCB9KSA9PiB7XG4gICAgY29uc3QgaXNTdGF0aWNJbWFnZSA9IHR5cGVvZiBzcmMgPT09IFwib2JqZWN0XCI7XG4gICAgY29uc3QgX3NyYyA9IGlzU3RhdGljSW1hZ2UgPyBzcmMuc3JjIDogc3JjO1xuICAgIGNvbnN0IG9yaWdpbmFsSW1hZ2VXaWR0aCA9IChpc1N0YXRpY0ltYWdlICYmIHNyYy53aWR0aCkgfHwgdW5kZWZpbmVkO1xuICAgIC8vIGlmIGl0IGlzIGEgc3RhdGljIGltYWdlLCB3ZSBjYW4gdXNlIHRoZSB3aWR0aCBvZiB0aGUgb3JpZ2luYWwgaW1hZ2UgdG8gZ2VuZXJhdGUgYSByZWR1Y2VkIHNyY3NldCB0aGF0IHJldHVybnNcbiAgICAvLyB0aGUgc2FtZSBpbWFnZSB1cmwgZm9yIHdpZHRocyB0aGF0IGFyZSBsYXJnZXIgdGhhbiB0aGUgb3JpZ2luYWwgaW1hZ2VcbiAgICBpZiAoaXNTdGF0aWNJbWFnZSAmJiBvcmlnaW5hbEltYWdlV2lkdGggJiYgd2lkdGggPiBvcmlnaW5hbEltYWdlV2lkdGgpIHtcbiAgICAgICAgY29uc3QgZGV2aWNlU2l6ZXMgPSBwcm9jZXNzLmVudi5fX05FWFRfSU1BR0VfT1BUUz8uZGV2aWNlU2l6ZXMgfHwgW1xuICAgICAgICAgICAgNjQwLCA3NTAsIDgyOCwgMTA4MCwgMTIwMCwgMTkyMCwgMjA0OCwgMzg0MCxcbiAgICAgICAgXTtcbiAgICAgICAgY29uc3QgaW1hZ2VTaXplcyA9IHByb2Nlc3MuZW52Ll9fTkVYVF9JTUFHRV9PUFRTPy5pbWFnZVNpemVzIHx8IFtcbiAgICAgICAgICAgIDE2LCAzMiwgNDgsIDY0LCA5NiwgMTI4LCAyNTYsIDM4NCxcbiAgICAgICAgXTtcbiAgICAgICAgY29uc3QgYWxsU2l6ZXMgPSBbLi4uZGV2aWNlU2l6ZXMsIC4uLmltYWdlU2l6ZXNdO1xuICAgICAgICAvLyBvbmx5IHVzZSB0aGUgd2lkdGggaWYgaXQgaXMgc21hbGxlciBvciBlcXVhbCB0byB0aGUgbmV4dCBzaXplIGluIHRoZSBhbGxTaXplcyBhcnJheVxuICAgICAgICBsZXQgbmV4dExhcmdlc3RTaXplID0gbnVsbDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhbGxTaXplcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKE51bWJlcihhbGxTaXplc1tpXSkgPj0gb3JpZ2luYWxJbWFnZVdpZHRoICYmXG4gICAgICAgICAgICAgICAgKG5leHRMYXJnZXN0U2l6ZSA9PT0gbnVsbCB8fCBOdW1iZXIoYWxsU2l6ZXNbaV0pIDwgbmV4dExhcmdlc3RTaXplKSkge1xuICAgICAgICAgICAgICAgIG5leHRMYXJnZXN0U2l6ZSA9IE51bWJlcihhbGxTaXplc1tpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5leHRMYXJnZXN0U2l6ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGdlbmVyYXRlSW1hZ2VVUkwoX3NyYywgbmV4dExhcmdlc3RTaXplKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBDaGVjayBpZiB0aGUgaW1hZ2UgaXMgYSByZW1vdGUgaW1hZ2UgKHN0YXJ0cyB3aXRoIGh0dHAgb3IgaHR0cHMpXG4gICAgaWYgKF9zcmMuc3RhcnRzV2l0aChcImh0dHBcIikpIHtcbiAgICAgICAgcmV0dXJuIGltYWdlVVJMRm9yUmVtb3RlSW1hZ2UoeyBzcmM6IF9zcmMsIHdpZHRoIH0pO1xuICAgIH1cbiAgICByZXR1cm4gZ2VuZXJhdGVJbWFnZVVSTChfc3JjLCB3aWR0aCk7XG59O1xuY29uc3QgZmFsbGJhY2tMb2FkZXIgPSAoeyBzcmMgfSkgPT4ge1xuICAgIGxldCBfc3JjID0gdHlwZW9mIHNyYyA9PT0gXCJvYmplY3RcIiA/IHNyYy5zcmMgOiBzcmM7XG4gICAgY29uc3QgaXNSZW1vdGVJbWFnZSA9IF9zcmMuc3RhcnRzV2l0aChcImh0dHBcIik7XG4gICAgLy8gaWYgdGhlIF9zcmMgZG9lcyBub3Qgc3RhcnQgd2l0aCBhIHNsYXNoLCB0aGVuIHdlIGFkZCBvbmUgYXMgbG9uZyBhcyBpdCBpcyBub3QgYSByZW1vdGUgaW1hZ2VcbiAgICBpZiAoIWlzUmVtb3RlSW1hZ2UgJiYgX3NyYy5jaGFyQXQoMCkgIT09IFwiL1wiKSB7XG4gICAgICAgIF9zcmMgPSBcIi9cIiArIF9zcmM7XG4gICAgfVxuICAgIHJldHVybiBfc3JjO1xufTtcbmNvbnN0IEV4cG9ydGVkSW1hZ2UgPSBmb3J3YXJkUmVmKCh7IHNyYywgcHJpb3JpdHkgPSBmYWxzZSwgbG9hZGluZywgY2xhc3NOYW1lLCB3aWR0aCwgaGVpZ2h0LCBvbkxvYWRpbmdDb21wbGV0ZSwgdW5vcHRpbWl6ZWQsIHBsYWNlaG9sZGVyID0gXCJibHVyXCIsIGJsdXJEYXRhVVJMLCBzdHlsZSwgb25FcnJvciwgLi4ucmVzdCB9LCByZWYpID0+IHtcbiAgICBjb25zdCBbaW1hZ2VFcnJvciwgc2V0SW1hZ2VFcnJvcl0gPSB1c2VTdGF0ZShmYWxzZSk7XG4gICAgY29uc3QgYXV0b21hdGljYWxseUNhbGN1bGF0ZWRCbHVyRGF0YVVSTCA9IHVzZU1lbW8oKCkgPT4ge1xuICAgICAgICBpZiAoYmx1ckRhdGFVUkwpIHtcbiAgICAgICAgICAgIC8vIHVzZSB0aGUgdXNlciBwcm92aWRlZCBibHVyRGF0YVVSTCBpZiBwcmVzZW50XG4gICAgICAgICAgICByZXR1cm4gYmx1ckRhdGFVUkw7XG4gICAgICAgIH1cbiAgICAgICAgLy8gY2hlY2sgaWYgdGhlIHNyYyBpcyBzcGVjaWZpZWQgYXMgYSBsb2NhbCBmaWxlIC0+IHRoZW4gaXQgaXMgYW4gb2JqZWN0XG4gICAgICAgIGNvbnN0IGlzU3RhdGljSW1hZ2UgPSB0eXBlb2Ygc3JjID09PSBcIm9iamVjdFwiO1xuICAgICAgICBjb25zdCBfc3JjID0gaXNTdGF0aWNJbWFnZSA/IHNyYy5zcmMgOiBzcmM7XG4gICAgICAgIGlmICh1bm9wdGltaXplZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgLy8gcmV0dXJuIHRoZSBzcmMgaW1hZ2Ugd2hlbiB1bm9wdGltaXplZFxuICAgICAgICAgICAgcmV0dXJuIF9zcmM7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIGltYWdlIGlzIGEgcmVtb3RlIGltYWdlIChzdGFydHMgd2l0aCBodHRwIG9yIGh0dHBzKVxuICAgICAgICBpZiAoX3NyYy5zdGFydHNXaXRoKFwiaHR0cFwiKSkge1xuICAgICAgICAgICAgcmV0dXJuIGltYWdlVVJMRm9yUmVtb3RlSW1hZ2UoeyBzcmM6IF9zcmMsIHdpZHRoOiAxMCB9KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBvdGhlcndpc2UgdXNlIHRoZSBnZW5lcmF0ZWQgaW1hZ2Ugb2YgMTBweCB3aWR0aCBhcyBhIGJsdXJEYXRhVVJMXG4gICAgICAgIHJldHVybiBnZW5lcmF0ZUltYWdlVVJMKF9zcmMsIDEwKTtcbiAgICB9LCBbYmx1ckRhdGFVUkwsIHNyYywgdW5vcHRpbWl6ZWRdKTtcbiAgICAvLyBjaGVjayBpZiB0aGUgc3JjIGlzIGEgU1ZHIGltYWdlIC0+IHRoZW4gd2Ugc2hvdWxkIG5vdCB1c2UgdGhlIGJsdXJEYXRhVVJMIGFuZCB1c2UgdW5vcHRpbWl6ZWRcbiAgICBjb25zdCBpc1NWRyA9IHR5cGVvZiBzcmMgPT09IFwib2JqZWN0XCIgPyBzcmMuc3JjLmVuZHNXaXRoKFwiLnN2Z1wiKSA6IHNyYy5lbmRzV2l0aChcIi5zdmdcIik7XG4gICAgY29uc3QgW2JsdXJDb21wbGV0ZSwgc2V0Qmx1ckNvbXBsZXRlXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgICAvLyBDdXJyZW50bHksIHdlIGhhdmUgdG8gaGFuZGxlIHRoZSBibHVyRGF0YVVSTCBvdXJzZWx2ZXMgYXMgdGhlIG5ldyBJbWFnZSBjb21wb25lbnRcbiAgICAvLyBpcyBleHBlY3RpbmcgYSBiYXNlNjQgZW5jb2RlZCBzdHJpbmcsIGJ1dCB0aGUgZ2VuZXJhdGVkIGJsdXJEYXRhVVJMIGlzIGEgbm9ybWFsIFVSTFxuICAgIGNvbnN0IGJsdXJTdHlsZSA9IHBsYWNlaG9sZGVyID09PSBcImJsdXJcIiAmJlxuICAgICAgICAhaXNTVkcgJiZcbiAgICAgICAgYXV0b21hdGljYWxseUNhbGN1bGF0ZWRCbHVyRGF0YVVSTCAmJlxuICAgICAgICBhdXRvbWF0aWNhbGx5Q2FsY3VsYXRlZEJsdXJEYXRhVVJMLnN0YXJ0c1dpdGgoXCIvXCIpICYmXG4gICAgICAgICFibHVyQ29tcGxldGVcbiAgICAgICAgPyB7XG4gICAgICAgICAgICBiYWNrZ3JvdW5kU2l6ZTogc3R5bGU/Lm9iamVjdEZpdCB8fCBcImNvdmVyXCIsXG4gICAgICAgICAgICBiYWNrZ3JvdW5kUG9zaXRpb246IHN0eWxlPy5vYmplY3RQb3NpdGlvbiB8fCBcIjUwJSA1MCVcIixcbiAgICAgICAgICAgIGJhY2tncm91bmRSZXBlYXQ6IFwibm8tcmVwZWF0XCIsXG4gICAgICAgICAgICBiYWNrZ3JvdW5kSW1hZ2U6IGB1cmwoJHthdXRvbWF0aWNhbGx5Q2FsY3VsYXRlZEJsdXJEYXRhVVJMfSlgLFxuICAgICAgICAgICAgZmlsdGVyOiBcInVybCgjc2hhcnBCbHVyKVwiLFxuICAgICAgICB9XG4gICAgICAgIDogdW5kZWZpbmVkO1xuICAgIGNvbnN0IEltYWdlRWxlbWVudCA9IChSZWFjdC5jcmVhdGVFbGVtZW50KEltYWdlLCB7IHJlZjogcmVmLCAuLi5yZXN0LCAuLi4od2lkdGggJiYgeyB3aWR0aCB9KSwgLi4uKGhlaWdodCAmJiB7IGhlaWdodCB9KSwgLi4uKGxvYWRpbmcgJiYgeyBsb2FkaW5nIH0pLCAuLi4oY2xhc3NOYW1lICYmIHsgY2xhc3NOYW1lIH0pLCAuLi4ob25Mb2FkaW5nQ29tcGxldGUgJiYgeyBvbkxvYWRpbmdDb21wbGV0ZSB9KSwgLi4uKHBsYWNlaG9sZGVyICYmIHtcbiAgICAgICAgICAgIHBsYWNlaG9sZGVyOiBibHVyU3R5bGUgfHwgYmx1ckNvbXBsZXRlID8gXCJlbXB0eVwiIDogcGxhY2Vob2xkZXIsXG4gICAgICAgIH0pLCAuLi4odW5vcHRpbWl6ZWQgJiYgeyB1bm9wdGltaXplZCB9KSwgLi4uKHByaW9yaXR5ICYmIHsgcHJpb3JpdHkgfSksIC4uLihpc1NWRyAmJiB7IHVub3B0aW1pemVkOiB0cnVlIH0pLCBzdHlsZTogeyAuLi5zdHlsZSwgLi4uYmx1clN0eWxlIH0sIGxvYWRlcjogaW1hZ2VFcnJvciB8fCB1bm9wdGltaXplZCA9PT0gdHJ1ZVxuICAgICAgICAgICAgPyBmYWxsYmFja0xvYWRlclxuICAgICAgICAgICAgOiAoZSkgPT4gb3B0aW1pemVkTG9hZGVyKHsgc3JjLCB3aWR0aDogZS53aWR0aCB9KSwgYmx1ckRhdGFVUkw6IGF1dG9tYXRpY2FsbHlDYWxjdWxhdGVkQmx1ckRhdGFVUkwsIG9uRXJyb3I6IChlcnJvcikgPT4ge1xuICAgICAgICAgICAgc2V0SW1hZ2VFcnJvcih0cnVlKTtcbiAgICAgICAgICAgIHNldEJsdXJDb21wbGV0ZSh0cnVlKTtcbiAgICAgICAgICAgIC8vIGV4ZWN1dGUgdGhlIG9uRXJyb3IgZnVuY3Rpb24gaWYgcHJvdmlkZWRcbiAgICAgICAgICAgIG9uRXJyb3IgJiYgb25FcnJvcihlcnJvcik7XG4gICAgICAgIH0sIG9uTG9hZGluZ0NvbXBsZXRlOiAocmVzdWx0KSA9PiB7XG4gICAgICAgICAgICAvLyBmb3Igc29tZSBjb25maWd1cmF0aW9ucywgdGhlIG9uRXJyb3IgaGFuZGxlciBpcyBub3QgY2FsbGVkIG9uIGFuIGVycm9yIG9jY3VycmVuY2VcbiAgICAgICAgICAgIC8vIHNvIHdlIG5lZWQgdG8gY2hlY2sgaWYgdGhlIGltYWdlIGlzIGxvYWRlZCBjb3JyZWN0bHlcbiAgICAgICAgICAgIGlmIChyZXN1bHQubmF0dXJhbFdpZHRoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgLy8gQnJva2VuIGltYWdlLCBmYWxsIGJhY2sgdG8gdW5vcHRpbWl6ZWQgKG1lYW5pbmcgdGhlIG9yaWdpbmFsIGltYWdlIHNyYylcbiAgICAgICAgICAgICAgICBzZXRJbWFnZUVycm9yKHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2V0Qmx1ckNvbXBsZXRlKHRydWUpO1xuICAgICAgICAgICAgLy8gZXhlY3V0ZSB0aGUgb25Mb2FkaW5nQ29tcGxldGUgY2FsbGJhY2sgaWYgcHJlc2VudFxuICAgICAgICAgICAgb25Mb2FkaW5nQ29tcGxldGUgJiYgb25Mb2FkaW5nQ29tcGxldGUocmVzdWx0KTtcbiAgICAgICAgfSwgc3JjOiBzcmMgfSkpO1xuICAgIC8vIFdoZW4gd2UgcHJlc2VudCBhIHBsYWNlaG9sZGVyLCB3ZSBhZGQgYSBzdmcgZmlsdGVyIHRvIHRoZSBpbWFnZSBhbmQgcmVtb3ZlIGl0IGFmdGVyIGVpdGhlclxuICAgIC8vIHRoZSBpbWFnZSBpcyBsb2FkZWQgb3IgYW4gZXJyb3Igb2NjdXJyZWRcbiAgICByZXR1cm4gYmx1clN0eWxlID8gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoUmVhY3QuRnJhZ21lbnQsIG51bGwsXG4gICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJub3NjcmlwdFwiLCBudWxsLFxuICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChJbWFnZSwgeyAuLi5yZXN0LCAuLi4od2lkdGggJiYgeyB3aWR0aCB9KSwgLi4uKGhlaWdodCAmJiB7IGhlaWdodCB9KSwgLi4uKGxvYWRpbmcgJiYgeyBsb2FkaW5nIH0pLCAuLi4oY2xhc3NOYW1lICYmIHsgY2xhc3NOYW1lIH0pLCBwbGFjZWhvbGRlcjogXCJlbXB0eVwiLCAuLi4odW5vcHRpbWl6ZWQgJiYgeyB1bm9wdGltaXplZCB9KSwgLi4uKHByaW9yaXR5ICYmIHsgcHJpb3JpdHkgfSksIHN0eWxlOiBzdHlsZSwgbG9hZGVyOiBpbWFnZUVycm9yIHx8IHVub3B0aW1pemVkID09PSB0cnVlXG4gICAgICAgICAgICAgICAgICAgID8gZmFsbGJhY2tMb2FkZXJcbiAgICAgICAgICAgICAgICAgICAgOiAoZSkgPT4gb3B0aW1pemVkTG9hZGVyKHsgc3JjLCB3aWR0aDogZS53aWR0aCB9KSwgc3JjOiBzcmMgfSkpLFxuICAgICAgICBJbWFnZUVsZW1lbnQsXG4gICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzdmdcIiwgeyBzdHlsZToge1xuICAgICAgICAgICAgICAgIGJvcmRlcjogMCxcbiAgICAgICAgICAgICAgICBjbGlwOiBcInJlY3QoMCAwIDAgMClcIixcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IDAsXG4gICAgICAgICAgICAgICAgbWFyZ2luOiBcIi0xcHhcIixcbiAgICAgICAgICAgICAgICBvdmVyZmxvdzogXCJoaWRkZW5cIixcbiAgICAgICAgICAgICAgICBwYWRkaW5nOiAwLFxuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBcImFic29sdXRlXCIsXG4gICAgICAgICAgICAgICAgd2lkdGg6IFwiMXB4XCIsXG4gICAgICAgICAgICB9IH0sXG4gICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZmlsdGVyXCIsIHsgaWQ6IFwic2hhcnBCbHVyXCIgfSxcbiAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZmVHYXVzc2lhbkJsdXJcIiwgeyBzdGREZXZpYXRpb246IFwiMjBcIiwgY29sb3JJbnRlcnBvbGF0aW9uRmlsdGVyczogXCJzUkdCXCIgfSksXG4gICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImZlQ29sb3JNYXRyaXhcIiwgeyB0eXBlOiBcIm1hdHJpeFwiLCBjb2xvckludGVycG9sYXRpb25GaWx0ZXJzOiBcInNSR0JcIiwgdmFsdWVzOiBcIjEgMCAwIDAgMCwgMCAxIDAgMCAwLCAwIDAgMSAwIDAsIDAgMCAwIDkgMFwiIH0pLFxuICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJmZUNvbXBvc2l0ZVwiLCB7IGluMjogXCJTb3VyY2VHcmFwaGljXCIsIG9wZXJhdG9yOiBcImluXCIgfSkpKSkpIDogKEltYWdlRWxlbWVudCk7XG59KTtcbmV4cG9ydCBkZWZhdWx0IEV4cG9ydGVkSW1hZ2U7XG4iXSwibmFtZXMiOlsiUmVhY3QiLCJmb3J3YXJkUmVmIiwidXNlTWVtbyIsInVzZVN0YXRlIiwiSW1hZ2UiLCJzcGxpdEZpbGVQYXRoIiwiZmlsZVBhdGgiLCJmaWxlbmFtZVdpdGhFeHRlbnNpb24iLCJzcGxpdCIsInBvcCIsImZpbGVQYXRoV2l0aG91dEZpbGVuYW1lIiwic2hpZnQiLCJmaWxlRXh0ZW5zaW9uIiwiZmlsZW5hbWVXaXRob3V0RXh0ZW5zaW9uIiwic3Vic3RyaW5nIiwibGFzdEluZGV4T2YiLCJwYXRoIiwiZmlsZW5hbWUiLCJleHRlbnNpb24iLCJnZW5lcmF0ZUltYWdlVVJMIiwic3JjIiwid2lkdGgiLCJpc1JlbW90ZUltYWdlIiwidXNlV2VicCIsInByb2Nlc3MiLCJlbnYiLCJuZXh0SW1hZ2VFeHBvcnRPcHRpbWl6ZXJfc3RvcmVQaWN0dXJlc0luV0VCUCIsInVuZGVmaW5lZCIsImluY2x1ZGVzIiwidG9VcHBlckNhc2UiLCJwcm9jZXNzZWRFeHRlbnNpb24iLCJjb3JyZWN0ZWRQYXRoIiwibGFzdENoYXIiLCJzdWJzdHIiLCJpc1N0YXRpY0ltYWdlIiwiZXhwb3J0Rm9sZGVyTmFtZSIsIm5leHRJbWFnZUV4cG9ydE9wdGltaXplcl9leHBvcnRGb2xkZXJOYW1lIiwiZ2VuZXJhdGVkSW1hZ2VVUkwiLCJjaGFyQXQiLCJ1cmxUb0ZpbGVuYW1lIiwidXJsIiwicmVwbGFjZSIsInRyaW0iLCJpbWFnZVVSTEZvclJlbW90ZUltYWdlIiwiZW5jb2RlZFNyYyIsIm9wdGltaXplZExvYWRlciIsIl9zcmMiLCJvcmlnaW5hbEltYWdlV2lkdGgiLCJkZXZpY2VTaXplcyIsIl9fTkVYVF9JTUFHRV9PUFRTIiwiaW1hZ2VTaXplcyIsImFsbFNpemVzIiwibmV4dExhcmdlc3RTaXplIiwiaSIsImxlbmd0aCIsIk51bWJlciIsInN0YXJ0c1dpdGgiLCJmYWxsYmFja0xvYWRlciIsIkV4cG9ydGVkSW1hZ2UiLCJwcmlvcml0eSIsImxvYWRpbmciLCJjbGFzc05hbWUiLCJoZWlnaHQiLCJvbkxvYWRpbmdDb21wbGV0ZSIsInVub3B0aW1pemVkIiwicGxhY2Vob2xkZXIiLCJibHVyRGF0YVVSTCIsInN0eWxlIiwib25FcnJvciIsInJlc3QiLCJyZWYiLCJpbWFnZUVycm9yIiwic2V0SW1hZ2VFcnJvciIsImF1dG9tYXRpY2FsbHlDYWxjdWxhdGVkQmx1ckRhdGFVUkwiLCJpc1NWRyIsImVuZHNXaXRoIiwiYmx1ckNvbXBsZXRlIiwic2V0Qmx1ckNvbXBsZXRlIiwiYmx1clN0eWxlIiwiYmFja2dyb3VuZFNpemUiLCJvYmplY3RGaXQiLCJiYWNrZ3JvdW5kUG9zaXRpb24iLCJvYmplY3RQb3NpdGlvbiIsImJhY2tncm91bmRSZXBlYXQiLCJiYWNrZ3JvdW5kSW1hZ2UiLCJmaWx0ZXIiLCJJbWFnZUVsZW1lbnQiLCJjcmVhdGVFbGVtZW50IiwibG9hZGVyIiwiZSIsImVycm9yIiwicmVzdWx0IiwibmF0dXJhbFdpZHRoIiwiRnJhZ21lbnQiLCJib3JkZXIiLCJjbGlwIiwibWFyZ2luIiwib3ZlcmZsb3ciLCJwYWRkaW5nIiwicG9zaXRpb24iLCJpZCIsInN0ZERldmlhdGlvbiIsImNvbG9ySW50ZXJwb2xhdGlvbkZpbHRlcnMiLCJ0eXBlIiwidmFsdWVzIiwiaW4yIiwib3BlcmF0b3IiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/next-image-export-optimizer/dist/ExportedImage.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/next-image-export-optimizer/dist/ExportedImage.js":
/*!************************************************************************!*\
  !*** ./node_modules/next-image-export-optimizer/dist/ExportedImage.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $$typeof: () => (/* binding */ $$typeof),
/* harmony export */   __esModule: () => (/* binding */ __esModule),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var next_dist_build_webpack_loaders_next_flight_loader_module_proxy__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/dist/build/webpack/loaders/next-flight-loader/module-proxy */ "(rsc)/./node_modules/next/dist/build/webpack/loaders/next-flight-loader/module-proxy.js");

const proxy = (0,next_dist_build_webpack_loaders_next_flight_loader_module_proxy__WEBPACK_IMPORTED_MODULE_0__.createProxy)(String.raw`/home/rlopez/projects/ADwebsite/node_modules/next-image-export-optimizer/dist/ExportedImage.js`)

// Accessing the __esModule property and exporting $$typeof are required here.
// The __esModule getter forces the proxy target to create the default export
// and the $$typeof value is for rendering logic to determine if the module
// is a client boundary.
const { __esModule, $$typeof } = proxy;
const __default__ = proxy.default;


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (__default__);

/***/ })

};
;